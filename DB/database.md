# 数据库原理

## 关系数据库设计理论

### 函数依赖

依赖关系：A->B，A决定B，B依赖于A。

键码： 集合{A1, A2, ..., An}决定了关系的其他属性且是最小的。

部分依赖关系：A->B，但是还存在真子集A'也能满足A'->B，说明是部分函数依赖；否则为完全函数依赖。

传递依赖：A->B, B->C => A->C。

### 可能出现的异常

· 冗余数据

· 修改异常：修改了一个记录中的信息，另一个记录中的相同信息却未修改（没有同时修改）

· 删除异常：只删除一个记录，但是同时删除了其他不应该删除的记录（删除了相关联的）

· 插入异常：想插入数据，但是因为其他相关联的设定不能插入。

### 数据库范式

数据库范式是设计数据库是的规范，避免产生异常。

第一范式(1NF)：属性是最小单元，不可继续分割。

第二范式(2NF)：1NF + 非主属性完全依赖于键码（主属性）。

第三范式(3NF)：2NF + 非主属性不依赖于其他非主属性（也相当于不传递依赖于主属性）。

## 数据库事务

### 定义

用户定义的一个数据库操作系列，是一个不可分割的工作单位，要么全部完成，要么全都不做。

### ACID

**A(Atomicity) 原子性**：不可分割。

**C(Consistency) 一致**性：所有事务对同一个数据的读取结果都是相同的。

**I(Isolation) 隔离性**：事务的修改在提交前对其他事务不可见。

**D(Durability) 持久性**：一旦事务提交，所做的修改将永久保存在数据库中。

## 并发一致性

并发环境下，导致数据库事务的隔离性遭到破坏。

### 问题

**修改丢失**：事务一的修改被事务二的修改覆盖。一未生效。

**读脏数据**：不同事务之间未隔离，事务二可以读到事务一的数据，一修改数据但未提交，二读取到修改后的数据，一撤销操作，二读到的数据成为脏数据。

**不可重复读**：不同时间多次读取同一事务的同一数据，事务一未完成前，其他事务更改了数据，会导致事务一多次读取该数据的值不相同。

（幻影读）：T1事务执行，影响一个范围的数据。此时T2对该范围进行了增/删，T1再次读取该范围时发现数据的数量改变了。本质也是不可重复读。

### 解决办法：隔离级别

**未提交读(Read Uncommitted)**：事务未提交，数据也对其他事务可见。

**提交读(Read Committed)**: 事务提交后数据才可见。

**可重复读(Repeatable Read)**：同一个事务中，多次读取一个数据的值是相同的。

**可串行化(Serializable)**：强制事务串行化执行，不产生并发。一般需要依靠锁来执行。

### 技术手段

#### 封锁

